// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSInit
#pragma kernel CSMain

#define GROUP_SIZE_X 32
#define GROUP_SIZE_Y 32

RWTexture2D<float4> Result;

float rand(float2 co) {
    return 0.5 + (frac(sin(dot(co.xy, float2(12.9898, 78.233))) * 43758.5453)) * 0.5;
}

float4 Color;

uniform int GenerationType;

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void CSInit(uint3 id : SV_DispatchThreadID) {
    switch (GenerationType) {
    case 0:  // Random
        Result[id.xy] = rand(id.xy) > 0.75 ? Color : float4(0, 0, 0, 1);
        break;
    case 1:  // FullTexture
        if (id.x % 7 == 0 || id.y % 3 == 0)
            Result[id.xy] = Color;
        else
            Result[id.xy] = float4(0, 0, 0, 1);
        break;
    case 2:  // RPentomino
        if ((id.x == 256 && id.y == 256) ||
            (id.x == 255 && id.y == 256) ||
            (id.x == 256 && id.y == 255) ||
            (id.x == 257 && id.y == 255) ||
            (id.x == 256 && id.y == 257))
        {
            Result[id.xy] = Color;
        }
        // Handle RPentomino generation
        // Set Result[id.xy] accordingly
        break;
    case 3:  // Acorn
        if ((id.x == 256 && id.y == 256 ) ||
            (id.x == 257 && id.y == 257 ) ||
            (id.x == 254 && id.y == 255 ) ||
            (id.x == 258 && id.y == 257 ) ||
            (id.x == 259 && id.y == 257 ) ||
            (id.x == 254 && id.y == 257 ) ||
            (id.x == 253 && id.y == 257 )
            )
        {
            Result[id.xy] = Color;
        }
        break;
    case 4:  // GosperGun
        if (
        (id.x == 256 && id.y == 256) ||
        (id.x == 255 && id.y == 255) ||
        (id.x == 254 && id.y == 254) ||
        (id.x == 255 && id.y == 256) ||
        (id.x == 255 && id.y == 257) ||
        (id.x == 254 && id.y == 258) ||
        (id.x == 253 && id.y == 256) ||
        (id.x == 252 && id.y == 259) ||
        (id.x == 252 && id.y == 253) ||
        (id.x == 251 && id.y == 259) ||
        (id.x == 251 && id.y == 253) ||
        (id.x == 250 && id.y == 258) ||
        (id.x == 250 && id.y == 254) ||
        (id.x == 249 && id.y == 256) ||
        (id.x == 249 && id.y == 255) ||
        (id.x == 249 && id.y == 257) ||
        (id.x == 240 && id.y == 256) ||
        (id.x == 240 && id.y == 255) ||
        (id.x == 239 && id.y == 256) ||
        (id.x == 239 && id.y == 255) ||
        (id.x == 259 && id.y == 255) ||
        (id.x == 259 && id.y == 254) ||
        (id.x == 259 && id.y == 253) ||
        (id.x == 260 && id.y == 255) ||
        (id.x == 260 && id.y == 254) ||
        (id.x == 260 && id.y == 253) ||
        (id.x == 261 && id.y == 256) ||
        (id.x == 261 && id.y == 252) ||
        (id.x == 263 && id.y == 257) ||
        (id.x == 263 && id.y == 256) ||
        (id.x == 263 && id.y == 252) ||
        (id.x == 263 && id.y == 251) ||
        (id.x == 273 && id.y == 254) ||
        (id.x == 273 && id.y == 253) ||
        (id.x == 274 && id.y == 254) ||
        (id.x == 274 && id.y == 253)
        )
        {
            Result[id.xy] = Color;
        }
        break;
    default:
        Result[id.xy] = rand(id.xy) > 0.75 ? Color : float4(0, 0, 0, 1); //Default to Random
        break;
    }
}

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void CSMain(uint3 id : SV_DispatchThreadID) {
    int liveNeighbors = 0;

    // Count live neighbors
    for (int x = -1; x <= 1; x++) {
        for (int y = -1; y <= 1; y++) {
            if (x == 0 && y == 0) continue;
            float2 position = float2(id.x, id.y);
            float2 offset = float2(x, y);
            float2 newPosition = position + offset;

            float4 result = Result[newPosition];
            if (result.x > 0 || result.y > 0 || result.z > 0) {
                liveNeighbors += 1;
            }
        }
    }

    // Use the Color directly
    float4 currentResult = Result[id.xy];

    if (currentResult.x > 0 || currentResult.y > 0 || currentResult.z > 0) {
        // Any live cell with fewer than two live neighbors dies
        // Any live cell with more than three live neighbors dies
        if (liveNeighbors < 2 || liveNeighbors > 3) {
            Result[id.xy] = float4(0, 0, 0, 1);
        }
        // Other cells survive
        else {
            Result[id.xy] = Color;
        }
    } else {
        // Any dead cell with exactly three live neighbors becomes a live cell (revives)
        if (liveNeighbors == 3) {
            Result[id.xy] = Color;
        } else {
            // Dead cells with other than three live neighbors remain dead
            Result[id.xy] = float4(0, 0, 0, 1);
        }
    }
}

